{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jonbe\\\\Desktop\\\\Personal\\\\Pixel_Art_Maker\\\\components\\\\pixelGrid.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport { getDimensions } from \"../hooks/getDimensions\";\nimport getMousePos from \"../hooks/getMousePosition\";\nimport { useEffect } from \"react\";\nimport \"../styles/pixelGrid.css\";\nexport default function PixelGrid() {\n  const numCells = 4;\n  const dimensions = getDimensions();\n  let canvasDim = Math.min(dimensions.width, dimensions.height) * 0.6; // Canvas is a square with the smallest dimension as a base\n\n  const mousePos = getMousePos();\n  let gridPoints = convertPositionToGrid(mousePos, canvasDim, numCells);\n  useEffect(() => drawRectOnGrid(gridPoints, canvasDim, numCells), []);\n  return __jsx(\"div\", {\n    className: \"centered\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 19\n    },\n    __self: this\n  }, __jsx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 20\n    },\n    __self: this\n  }, \"Window's dimensions are \", dimensions.width, \" by \", dimensions.height), __jsx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21\n    },\n    __self: this\n  }, \"Mouse was last seen on canvas at point: (\", mousePos.x, \" , \", mousePos.y, \")\"), __jsx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22\n    },\n    __self: this\n  }, \"Last active gridpoint based on position: (\", gridPoints.x, \" , \", gridPoints.y, \")\"), __jsx(\"canvas\", {\n    className: \"pixelGrid\",\n    id: \"pixelGrid\",\n    width: canvasDim,\n    height: canvasDim,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23\n    },\n    __self: this\n  }));\n}\n\nfunction convertPositionToGrid(pos, canvasDim, numCells) {\n  let cellsPerRow = Math.sqrt(numCells);\n  let cellSize = canvasDim / cellsPerRow;\n  return {\n    x: convertPositionToGridValues(pos.x, cellSize, cellsPerRow),\n    y: convertPositionToGridValues(pos.y, cellSize, cellsPerRow)\n  };\n}\n\nfunction convertPositionToGridValues(val, cellSize, cellsPerRow) {\n  let result = Math.ceil(val / cellSize) - 1;\n  if (result > cellsPerRow - 1) result = cellsPerRow - 1;\n  if (result < 0) result = 0;\n  return result;\n}\n\nfunction drawRectOnGrid(gridPoints, canvasDim, numCells) {\n  let canvas = document.getElementById(\"pixelGrid\");\n  let ctx = canvas.getContext(\"2d\");\n  let p = convertGridToPx(gridPoints, canvasDim, numCells);\n  ctx.beginPath(p.x, p.y, p.w, p.h);\n  ctx.stroke();\n  console.log(\"I think i drew a square :P\");\n}\n\nfunction convertGridToPx(gridPoints, canvasDim, numCells) {\n  let scale = canvasDim / Math.sqrt(numCells);\n  return {\n    x: gridPoints.x * scale,\n    y: gridPoints.y * scale,\n    w: (gridPoints.x + 1) * scale,\n    h: (gridPoints.y + 1) * scale\n  };\n}","map":{"version":3,"sources":["C:/Users/jonbe/Desktop/Personal/Pixel_Art_Maker/components/pixelGrid.js"],"names":["getDimensions","getMousePos","useEffect","PixelGrid","numCells","dimensions","canvasDim","Math","min","width","height","mousePos","gridPoints","convertPositionToGrid","drawRectOnGrid","x","y","pos","cellsPerRow","sqrt","cellSize","convertPositionToGridValues","val","result","ceil","canvas","document","getElementById","ctx","getContext","p","convertGridToPx","beginPath","w","h","stroke","console","log","scale"],"mappings":"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","sourcesContent":["import { getDimensions } from \"../hooks/getDimensions\";\r\nimport getMousePos from \"../hooks/getMousePosition\";\r\nimport { useEffect } from \"react\";\r\n\r\nimport \"../styles/pixelGrid.css\";\r\n\r\nexport default function PixelGrid() {\r\n    const numCells = 4;\r\n\r\n    const dimensions = getDimensions();\r\n    let canvasDim = Math.min(dimensions.width, dimensions.height) * 0.6; // Canvas is a square with the smallest dimension as a base\r\n\r\n    const mousePos = getMousePos();\r\n    let gridPoints = convertPositionToGrid(mousePos, canvasDim, numCells);\r\n\r\n    useEffect(() => drawRectOnGrid(gridPoints, canvasDim, numCells), []);\r\n\r\n    return (\r\n        <div className=\"centered\">\r\n            <p>Window's dimensions are {dimensions.width} by {dimensions.height}</p>\r\n            <p>Mouse was last seen on canvas at point: ({mousePos.x} , {mousePos.y})</p>\r\n            <p>Last active gridpoint based on position: ({gridPoints.x} , {gridPoints.y})</p>\r\n            <canvas className=\"pixelGrid\" id=\"pixelGrid\" width={canvasDim} height={canvasDim}></canvas>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction convertPositionToGrid(pos, canvasDim, numCells) {\r\n    let cellsPerRow = Math.sqrt(numCells);\r\n    let cellSize = canvasDim / cellsPerRow;\r\n\r\n    return {\r\n        x: convertPositionToGridValues(pos.x, cellSize, cellsPerRow),\r\n        y: convertPositionToGridValues(pos.y, cellSize, cellsPerRow)\r\n    };\r\n}\r\n\r\nfunction convertPositionToGridValues(val, cellSize, cellsPerRow) {\r\n    let result = Math.ceil(val / cellSize) - 1;\r\n    if (result > cellsPerRow - 1) result = cellsPerRow - 1;\r\n    if (result < 0) result = 0;\r\n    return result;\r\n}\r\n\r\nfunction drawRectOnGrid(gridPoints, canvasDim, numCells) {\r\n    let canvas = document.getElementById(\"pixelGrid\");\r\n    let ctx = canvas.getContext(\"2d\");\r\n    let p = convertGridToPx(gridPoints, canvasDim, numCells)\r\n    ctx.beginPath(p.x, p.y, p.w, p.h);\r\n    ctx.stroke();\r\n    console.log(\"I think i drew a square :P\");\r\n}\r\n\r\nfunction convertGridToPx(gridPoints, canvasDim, numCells) {\r\n    let scale = canvasDim / Math.sqrt(numCells);\r\n    return {\r\n        x: gridPoints.x * scale,\r\n        y: gridPoints.y * scale,\r\n        w: (gridPoints.x + 1) * scale,\r\n        h: (gridPoints.y + 1) * scale\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}